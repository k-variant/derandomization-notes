\begin{lecture}{1}{The Class prBPP}{January 23, 2020}
\label{lec:01}

\subsection*{The Upshot}

\begin{enumerate}
  \item Randomness is necessary in many computational settings. Is randomness
    necessary for polynomial-time computation? There are good reasons to expect
    it is not! This is a fundamental question we will investigate in this
    course.
  \item Promise problems are a natural generalization of languages, and the
    theory of probabilistic algorithms for promise problems is richer than
    for that of languages.
  \item The class $\prBPP$ has a complete problem ($\CAPP$) under deterministic
    polynomial-time reductions. Hence to prove $\prBPP = \prP$ it suffices
    to give a deterministic polynomial-time algorithm for $\CAPP$.
  \item The class $\prBPP$ admits a time-hierarchy theorem.
  \item Probabilistic search problems can be reduced to probabilistic decision
    problems, meaning the theory we will develop around the class of decision
    problems $\prBPP$ will apply to the search analog as well.
\end{enumerate}

\subsection{Equivalent Definitions of prBPP via Amplification}

A \emph{promise problem} is a pair $\Pi = (\Pi_Y, \Pi_N) \subseteq \{0, 1\}^*
\times \{0, 1\}^*$ such that $\Pi_Y \cap \Pi_N = \emptyset$. Promise problems
generalize languages in the case that $\Pi_Y \cup \Pi_N = \Pi$.

The complexity class $\prBPP$ is the set of all promise problems $\Pi$ such
that there exists a probabilistic polynomial-time Turing machine $M$ deciding
$\Pi$ with probability $2/3$. By a classic amplification technique, the
correctness probability $2/3$ can be replaced with any other constant and we
obtain the same set of problems.

\begin{definition}
  An \emph{$(\eps, \delta)$-sampler} is a function $s :
  \set{0,1}^{\overline{T}} \times \set{0,1}^\ell \to \set{0,1}^T$ such that for
  all $f : \set{0,1}^T \to \set{0,1}$ and for all $z \in
  \set{0,1}^{\overline{T}}$ it holds that \[
    |\Exp_i f(s(z, i)) - \Exp_x f(x)| \le \eps.
  \]
\end{definition}

\begin{theorem}
  For all $\eps > 0$ there exists a polynomial-time computable $(\eps,
  \delta)$-sampler with $\overline{T} = \poly(T)$, $\ell = O(\log
  \overline{T}/\eps)$ and $\delta = 2^{\overline{T}^\eps - \overline{T}}$.
\end{theorem}

\begin{corollary}
  The class $\prBPP$ can be equivalently defined with an error of $2^{T^\eps -
  T}$ instead of 1/3, where $T = T(n)$ is the number of random bits.
\end{corollary}

\subsection{The Complexity of BPP}

What do we know about the placement $\BPP$ with respect to other complexity
classes? A trivial inclusion is $\BPP \subseteq \PSPACE \subseteq \EXP
\subseteq \NEXP$. Open problem: prove $\BPP \ne \NEXP$.

\begin{theorem}
  $\BPP \subseteq \Ppoly$.
\end{theorem}

\begin{proof}
  Since the class $\BPP$ is the same even with error $2^{-2n}$, there exists
  some choice of randomness that works for all inputs.
\end{proof}

\subsection{The Circuit Acceptance Probability Problem (CAPP)}

\begin{definition}
  The Circuit Acceptance Probability Problem ($\CAPP$) is the following: The input
  is a description of a circuit. The YES instances are all those descriptions
  of circuits that accept at least 2/3 of their inputs, and the NO instances
  are all those descriptions that accept at most 1/3 of their inputs.
\end{definition}

\subsection{A Time-Hierarchy Theorem}

\subsection{Reducing Search Problems to Decision Problems}

\subsection{Two-Sided Error vs.\ One-Sided Error}

\end{lecture}
