
\newcommand{\F}{\mathcal{F}}
\newcommand{\fH}{\mathcal{H}}


\title{Doubly Efficient Proof Systems}


\begin{lecture}{9}{Doubly Efficient Proof Systems}{March 24, 2022}\label{lec:09}
\maketitle

%\tableofcontents

\subsection*{The Upshot}%We will prove this theorem for the class $\mathcal{L}$-uniform $\mathcal{NC}$.


\begin{definition}\label{def:logspaceuniform}
	A circuit class $\{C_n\}_{n \geq 1}$ is called log-space uniform if there exists a TM which on input $1^n$ outputs the circuit $C_n$ of size $s(n)$ by using space atmost $O(\log(s(n)))$.
\end{definition}


Note that there are many notions of uniformness, and we have been looking at $\mathcal{P}$-uniform circuit classes, where the circuits can be generated by a Turing Machine in polynomial time. The above definition is more restricted, as the Turing Machines generating the circuits are only allowed to use logarithmic space. 

\begin{definition}
	A language $L$ is said to be in $\mathcal{DEIP}(p(n), v(n))$, if there is an interactive protocol which accepts the language with completeness and soundness atleast $\frac23$ where the prover runs in time $p(n)$ and the verifier runs in time $v(n)$ on inputs of size $n$.
\end{definition}

Observe that $\mathcal{DEIP}(p(n), q(n)) = \mathcal{BPP}$ for polynomial $p(n)$ and $q(n)$. 

We want to prove that,

\begin{theorem}\label{thm:main}
	Any language $L$ which can be computed by a family of $O(\log s(n))$-space uniform boolean circuits of size $s(n)$ and depth $d(n)$ has an interactive proof where,
	
	\begin{enumerate}
		\item An honest prover runs in time $O(\poly(s(n)))$. 
		\item The verifier runs in time $O(n \poly(d(n), \log s(n)))$ and space $O(\log s(n))$.
		\item The protocol has completeness 1 and soundness 1/2. 
		\item The communication complexity is $O(d(n)\poly(\log(s(n))))$ with public randomness. 
	\end{enumerate}
\end{theorem}


This implies that $\mathcal{L}$-uniform $\mathcal{NC}$ is contained in $\mathcal{DEIP}(\poly(n), \tilde{O}(n))$.


\subsection{Circuit Specification and Arithmetization}


The prover and the verifier are given a boolean circuit $C$ of size $s = s(n)$ and depth $d= d(n)$, and an input $x$. The prover wants to prove to a space bounded verifier that $C(x)=1$. 

We assume our circuit $C$ has the following form. 

\begin{enumerate}
	\item The fan-in of each gate in the circuit is 2. This increases the depth of the circuit by a factor of $O(\log s)$.
	\item We number the layers in the circuit with integers from 0 to $d$, such that layer $i$ is at a distance of $i$ from the output layer.
	\item The circuit has exactly $s$ gates at each layer. This can be enforced by adding dummy gates which do not feed into any gates. 
	\item All the gates in layer $i$ have inputs only from the gates in layer $i+1$ for all $i < d$. We can enforce this by adding duplicate gates with atmost a polynomial increase in the size of the circuit.
	\item Each gate in the circuit is a NAND gate, as these are universal and any other $\wedge$ or $\vee$ gates can be replaced by a constant number of NAND gates.
\end{enumerate}

We number the gates in each layer in the circuit from $\{0,1,\ldots, s-1\}$. Let $g_{i,j}$ denote the gate in layer $i$ at position $j$.  

\begin{definition}\label{def:psis}
	We define the circuit gate functios $\psi_i:\{0,1,\ldots, s-1\}^3 \rightarrow \{0,1\}$ for $i \in \{0, 1, \ldots, d-1\}$ as follows. 
	
	\[
	\psi_i(a,b,c) = \begin{cases}
	1  \hspace{3mm}\textrm{   if input to $g_{i,a}$ is $g_{i+1,b}, g_{i+1,c}$} \\
	0 \hspace{3mm}\textrm{   otherwise}
	\end{cases}
	\]
	The $d$ functions defined above completely describe circuit $C$.
\end{definition}



Let $\F$ be a field and $\fH$ be a subset of $\F$. 

\begin{lemma}\label{lem:lde}
Given a function $W:\fH^k \rightarrow \fH$ on $k$ variables, we can construct another function $\tilde{W}:\F^k \rightarrow F$ which agrees with $W$ on all inputs $x \in \fH^k$, and has degree atmost $|\fH|-1$ in each variable. $\tilde{W}$ can both be generated and evaluated in $O(\poly(|\F|^k))$ time and $O(\log k + \log |\F|)$ space. This function $\tilde{W}$ is called the low degree extension of $W$. 
\end{lemma}

\begin{proof}
	
First let us define a function $\delta:\F^{2k} \rightarrow F$ which takes as input $x, y \in \F^k$ and does the following.

\[
\delta(x,y) = \begin{cases}
1 \hspace{3mm} \textrm{if $x, y \in \fH^k, x=y$} \\
0 \hspace{3mm} \textrm{if $x, y \in \fH^k, x \neq y$} 
\end{cases}
\]

On other inputs, the output of $\delta$ can be anything in $\F$.
	
\begin{equation}
\delta(x,y) = \prod_{i=1}^k \sum_{a \in \fH} \prod_{b \in \fH\setminus\{a\}} \frac{(x_i-b)(y_i-b)}{(a-b)^2}
\end{equation}

By construction, the degree of $\delta$ is atmost $|\fH|-1$ in each variable and $\delta$ has an arithmetic circuit of size $O(\poly(|\F|, k))$. (The circuit contains $k-1$ product gates, and a smaller circuit of size $|\fH|^2$ as input to these product gates.) This circuit can both be generated and evaluated in $O(\poly(|\F|, k))$ time and $O(\log k + \log |\F|)$ space. 

Using $\delta$ we define $\tilde{W}$ as,
	
	\begin{equation*}
	\tilde{W}(x) = \sum_{a \in \fH^k} \delta(a,x) W(a). 
	\end{equation*}
	
$\tilde{W}$ has an arithmetic circuit of size $O(|\F|^k \cdot \poly(k , |\F|))$ by the above construction. This arithmetic circuit can be evaluated and generated in time $O(|\F|^k \cdot \poly(k , |\F|))$ and space $O(m \log (|\F|))$.

\end{proof}

Henceforth, for any function $f: \fH \rightarrow \fH$, we use $\tilde{f}:\F \rightarrow \F$ to denote the low degree extension of $f$ to field $\F$.

We pick two fields, $\fH, \F$ and an integer $m$ with $\{0,1\} \subset \fH \subset \F$ such that the following conditions hold.

\begin{align*}
\log s &\leq |\fH| \leq \poly(\log s) \\
|\F| &\leq \poly(|\fH|) \\
s &\leq |\fH|^m \leq \poly(s)
\end{align*}

The prover needs to operate over $\F^m$ and the verifier works with the fields $\F$ and $\fH$. This helps us understand why the parameters have been defined as shown above. 

We need $|\F| \geq \poly(\log s, d)$ for error correction to get good soundness. If field $|\fH| = o(\log s)$, $\F^m$ would be $\omega(\poly(s))$, as the value of $m$ would be too large. This would make the prover require super polynomial space and time, but we want the prover to be efficient.  
 

Now we move on to arithmetizing the circuit $C$. Throughout this section, we fix the input $x$, as this is known to both the prover and the verifier. The prover is interested in proving $C(x)=1$ for a fixed $x$. 

 Each layer $i$ of $C$ can be viewed as a value $\ell_i \in \{0,1\}^{s}$, where the value at position $j$ is the output of the gate at position $j$ in layer $i$. For example, the input layer $\ell_d$ is $x0^{n-s}$ (we can assume that the dummy gates have output 0). The output layer $\ell_0$ is $C(x)0^{s-1}$. 

Function $L_i:\{0,1, \ldots, s-1\} \rightarrow \{0,1\}$ for $i \in [d]$ is used to fix the output on layer $i$. $L_i(j)$ is defined as the output on gate $j$ in layer $i$ of $C$.

If we assign a mapping from $\{0,1, \ldots, s-1\}$ to $\fH^m$ (size of $\fH^m$ is greater than $s$) which is easy to compute, then $L_i$ can be seen as a function from $\fH^m$ to $\{0,1\}$. The mapping can be any one-one mapping. 

These $d$ functions $L_i$s fix the output on $x$ on all the gates of the circuit, and our $d$ functions $\psi_i$s from \cref{def:psis} describe the circuit $C$. We define $\tilde{L_i}: \F^m \rightarrow \F, \tilde{\psi_i}: \F^{3m} \rightarrow \F$ for $i\in \{0,1,\ldots, d\}$ as their low degree extensions from \cref{lem:lde}, and work with these functions.



\subsection{Sumcheck Barebones Protocol}

In this section we prove \cref{thm:main} when the verifier has access to oracles of low degree extensions of circuit specification functions from \cref{def:psis}. In the next section, we show how the verifer can compute $\tilde{\psi_i}$s by using the log-space uniformity (from \cref{def:logspaceuniform}) of $C$. 

The prover wants to prove to the verifier that $\tilde{L_0}(1^m) = 1$ if $1^m$ is the value in $\fH^m$ mapped to the output gate. The prover can reduce this task to proving that $\tilde{L_1}(z_1) = r_1$ for $z_1, \in \F^m$, $r_1 \in \F$. More generally, the prover can reduce the task of proving $\tilde{L_i}(z_i) = r_i$ in some layer $i$ to the verifier to the task of proving that $\tilde{L_{i+1}}(z_{i+1}) = r_{i+1}$ in the next layer $i+1$ by running a sumcheck protocol. After $d$ different sumcheck protocols, the verifier has to check whether $\tilde{L_d}(z_d) = r_d$ in the input layer, which it can verify without the aid of the prover in $O(n\cdot \poly(d, \log s))$ space.  


\subsection{Highly Uniform Circuit Oracles}

%\bibliographystyle{alpha}
%\bibliography{ref}
\end{lecture}
